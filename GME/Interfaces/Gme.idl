
import "oaidl.idl";
import "ocidl.idl";

#ifndef MGAIDL_IMPORTED
import "Mga.idl";
#endif

#ifndef INTERFACECOLL_INCLUDED
#include "InterfaceColl.h"
#endif

#ifndef INTERFACEVERSION_INCLUDED
#include "InterfaceVersion.h"
#endif


#define GMEIDL_IMPORTED

interface IGMEOLEColl;

typedef enum  msgtype_enum {
	MSG_NORMAL = 0,
	MSG_INFO = 1,
	MSG_WARNING = 2,
	MSG_ERROR =3
} msgtype_enum;

typedef enum  editmode_enum {
	MODE_EDIT = 0,
	MODE_CONNECT = 1,
	MODE_DISCONNECT = 2,
	MODE_SET =3,
	MODE_ZOOM =4,
	MODE_VISUALIZE =5
} editmode_enum;

typedef enum  bar_enum {
	BAR_HORIZ = 0,
	BAR_VERTI = 1
} bar_enum;

typedef enum  scroll_enum {
	SCROL_UP = 0,
	SCROL_DOWN = 1,
	SCROL_PGUP = 2,
	SCROL_PGDN = 3,
	SCROL_HOME = 4,
	SCROL_END = 5
} scroll_enum;

typedef enum  attribpanel_page {
	PAGE_ATTRIB = 0,
	PAGE_PREF = 1,
	PAGE_PROP = 2
} attribpanel_page;

// --------------------------- Gme IDL

[ uuid(9FF8F4E0-E0C9-11d3-B376-005004D38590),
	oleautomation,
	dual
]
interface IMgaDataSource : IDispatch
{
	[propget, id(1), helpstring("property Data")]
	HRESULT Data([out, retval] IUnknown **p);

	[propget, id(2), helpstring("property Data")]
	HRESULT Folders([out, retval] IUnknown **p);

	[propget, id(3), helpstring("property RegistryData")]
	HRESULT RegistryData([out, retval] IUnknown **p);

	[propget, id(4), helpstring("property Project")]
	HRESULT Project([out, retval] IUnknown **p);
};

interface IGMEOLEIt;

//  Primary dispatch interface for CGMEOLEApp
	
[ uuid(81191A44-B898-4143-BF8B-CA7501FEC19A), 
	oleautomation,
	dual
]
interface IGMEOLEApp : IDispatch
{
	// properties:
	[propput, id(1)] HRESULT Visible([in] VARIANT_BOOL isVisible);
	[propget, id(1)] HRESULT Visible([out, retval] VARIANT_BOOL* isVisible);
	[propget, id(2)] HRESULT Version([out, retval] BSTR* versionStr);
	[propget, id(3)] HRESULT VersionMajor([out, retval] short* n);
	[propget, id(4)] HRESULT VersionMinor([out, retval] short* n);
	[propget, id(5)] HRESULT VersionPatchLevel([out, retval] short* n);
	[propget, id(6)] HRESULT Models([out, retval] IGMEOLEColl** coll);
	[propget, id(7)] HRESULT MgaProject([out, retval] IMgaProject** project);
	[propget, id(8)] HRESULT Panels([out, retval] IGMEOLEColl** coll);
	[propput, id(9)] HRESULT ConsoleContents([in] BSTR contents);
	[propget, id(9)] HRESULT ConsoleContents([out, retval] BSTR* contents);
			
	// methods:
	[id(10)] HRESULT CreateProject([in] BSTR metaname, [in] BSTR connstr);
	[id(11)] HRESULT OpenProject([in] BSTR connstr);
	[id(12)] HRESULT CreateProjectDialog();
	[id(13)] HRESULT OpenProjectDialog();
	[id(14)] HRESULT CloseProject([in] VARIANT_BOOL saveOnClose);
	[id(15)] HRESULT SaveProject();
	[id(16)] HRESULT SaveProjectAs([in] BSTR connstr);
	[id(17)] HRESULT SaveProjectAsDialog();
	[id(18)] HRESULT ExportProject([in] BSTR connstr);
	[id(19)] HRESULT ImportProject([in] BSTR connstr);
	[id(20)] HRESULT ConstraintsDialog();
	[id(21)] HRESULT CheckAllConstraints();
	[id(22)] HRESULT RegisterParagimsDialog();
	[id(23)] HRESULT RegisterComponentsDialog();
	[id(24)] HRESULT RunComponent([in] BSTR progID);
	[id(25)] HRESULT RunComponentDialog();
	[id(26)] HRESULT SettingsDialog();
	[id(27)] HRESULT Undo();
	[id(28)] HRESULT Redo();
	[id(29)] HRESULT ClearUndoQueue();
	[id(30)] HRESULT ProjectPropertiesDialog();
	[id(31)] HRESULT ShowHelpContents();
	[id(32)] HRESULT ShowAbout();
	[id(33)] HRESULT ShowFCO([in] IMgaFCO* mgaFCO, [in, defaultvalue(0)] VARIANT_BOOL inParent);
	[id(34)] HRESULT ConsoleMessage([in] BSTR msg, [in]msgtype_enum type);
	[id(35)] HRESULT ConsoleClear();
	[id(36)] HRESULT ConsoleNavigateTo([in] BSTR url);

	[id(37), helpstring("method ChangeEditmode")] HRESULT ChangeEditmode([in] editmode_enum mode);
	[id(38), helpstring("method GridShow")] HRESULT GridShow([in] VARIANT_BOOL show);
	[id(39), helpstring("method AttributepanelPage")] HRESULT AttributepanelPage([in] attribpanel_page page);

	[propget, id(40)] HRESULT OleIt([out, retval] IGMEOLEIt ** mgamodel);

	// methods for disabling components (interpreters, plugins) on the toolbar and in File/Run Interpreter menu
	// Users do NOT need to call SetCompFiltering
	[id(41), helpstring("method for disabling/enabling a component")] 
	HRESULT DisableComp( [in] BSTR pCompProgID, [in] VARIANT_BOOL pDisable);

	// disable automatically a component whenever a model specified in the 2nd parameter
	// is opened AND focused in the editing window
	//    e.g. : gme.DisableCompForKinds( "MGA.Interpreter.SFInterpreter", "Primitive;Compound")
	// specify the special string below to disable components when no model is open at all
	//    e.g. : gme.DisableCompForKinds( "MGA.Interpreter.SFInterpreter", "_NO_MODEL_IS_OPEN_")
	// Users NEED to call SetCompFiltering to activate this feature (before or after)
	[id(42), helpstring("method for disabling/enabling a component when certain model kinds are shown")] 
	HRESULT DisableCompForKinds( [in] BSTR pCompProgID, [in] BSTR pKindSequenceDelimitedBySemicolon);

	// this method must be used to turn the DisableCompForKinds feature on
	[id(43), helpstring("method for turning on/off component filtering")] 
	HRESULT SetCompFiltering( [in] VARIANT_BOOL pTurnOn);

	// is the feature turned on?
	[id(44), helpstring("inquire component filtering state")] 
	HRESULT GetCompFiltering( [out, retval] VARIANT_BOOL* pPtrTurnedOn);

	[id(45), helpstring("Sets the working directory. Will affect the dialogs when the user will Open or Save As")]
	HRESULT SetWorkingDirectory( [in] BSTR pDirPath);

	[id(46), helpstring("Exit Application")]
	HRESULT Exit();

	[id(47), helpstring("Refresh Lib")]
	HRESULT RefreshLib( [in] BSTR pLibName, [in] VARIANT_BOOL ungroup, [out,retval] long* numOfErrors);
};


[ uuid(F2181278-749F-459d-8700-92F088B80D72),
	oleautomation,
	dual 
]
interface IGMEOLEIt : IDispatch // the current/active opened view (model)
{
	// methods and properties similar to those defined in IGMEOLEModel:

	// properties:
	[propget, id(1)] HRESULT Valid([out, retval] VARIANT_BOOL* isValid);
	[propget, id(2)] HRESULT Aspects([out, retval] IGMEOLEColl** coll);
	[propget, id(3)] HRESULT MgaModel([out, retval] IMgaModel** model);

	// methods:

	[id(5)] HRESULT Print();
	[id(6)] HRESULT PrintDialog();
	[id(7)] HRESULT DumpWindowsMetaFile([in] BSTR filePath);
	[id(8)] HRESULT CheckConstraints();
	[id(9)] HRESULT RunComponent([in] BSTR appID);
	[id(10)] HRESULT RunComponentDialog();
	[id(11)] HRESULT Close();
	[id(12)] HRESULT GrayOutFCO([in] VARIANT_BOOL bGray, [in] VARIANT_BOOL bNeighbours, [in] IMgaFCOs* mgaFCO);
	[id(13)] HRESULT GrayOutHide();
	[id(14)] HRESULT ShowSetMembers([in] IMgaFCO* mgaFCO);
	[id(15)] HRESULT HideSetMembers();
	[id(16)] HRESULT Zoom([in] DWORD percent);
	[id(17)] HRESULT ZoomTo([in] IMgaFCOs* mgaFCOs);
	[id(18)] HRESULT Scroll([in] bar_enum, [in] scroll_enum);


	// methods allowing the user to generate models ie. from the scripting window:
	[helpstring("ShowFCO - accepts relative path both up and down. For models only: If InParent == true shown selected in parent, otherwise opened.")]
	HRESULT ShowFCO( [in] BSTR path, [in, defaultvalue(0)] VARIANT_BOOL inParent );
	[helpstring("ShowFCOPtr - changes the view to fco.")]
	HRESULT ShowFCOPtr( [in] IMgaFCO* fco, [in, defaultvalue(0)] VARIANT_BOOL inParent );

	HRESULT Child( [in] BSTR name, [out,retval] IMgaFCO** child_fco );
	HRESULT Create( [in] BSTR part, [in] BSTR name, [out,retval] IMgaFCO** new_fco );
	[helpstring("creates a 'part' named 'name' in child_as_parent model")]
	HRESULT CreateInChild( [in] BSTR child_as_parent, [in] BSTR part, [in] BSTR name, [out,retval] IMgaFCO** new_fco );
	HRESULT CreateInChildFCO( [in] IMgaFCO* child_as_parent, [in] BSTR part, [in] BSTR name, [out,retval] IMgaFCO** new_fco );

	HRESULT Duplicate([in] BSTR existing_fco_name, [in] BSTR new_fco_name, [out,retval] IMgaFCO** new_fco );
	HRESULT DuplicateFCO([in] IMgaFCO* existing_fco, [in] BSTR new_fco_name, [out,retval] IMgaFCO** new_fco );

	HRESULT Rename( [in] BSTR oldname, [in] BSTR newname);
	HRESULT SetName( [in] IMgaFCO*, [in] BSTR name);

	HRESULT Include( [in] BSTR setname, [in] BSTR name);
	HRESULT Exclude( [in] BSTR setname, [in] BSTR membername);

	HRESULT IncludeFCO( [in] IMgaSet* p_set, [in] IMgaFCO* fco);
	HRESULT ExcludeFCO( [in] IMgaSet* p_set, [in] IMgaFCO* fco);

	HRESULT Connect( [in] BSTR src_part, [in] BSTR dst_part, [in] BSTR connection_role, [out, retval] IMgaConnection ** conn );
	HRESULT Disconnect( [in] BSTR src_part, [in] BSTR dst_part, [in] BSTR connection_name);

	[helpstring("creates a connection. src_part_1 must be the model/reference, src_part_2 must be the port's name. if portname empty connection drawn to src_part_1")]
	HRESULT ConnectThruPort( [in] BSTR src_part_1, [in] BSTR src_part_2, [in] BSTR dst_part_1, [in] BSTR dst_part_2, [in] BSTR connection_role, [out, retval] IMgaConnection ** conn );
	HRESULT ConnectThruPortFCO( [in] IMgaFCO* src_part_1, [in] IMgaFCO* src_part_2, [in] IMgaFCO* dst_part_1, [in] IMgaFCO* dst_part_2, [in] BSTR connection_role, [out, retval] IMgaConnection ** conn);
	HRESULT DisconnectThruPort( [in] BSTR src_part_1, [in] BSTR src_part_2, [in] BSTR dst_part_1, [in] BSTR dst_part_2, [in] BSTR connection_name);


	HRESULT ConnectFCOs( [in] IMgaFCO* src_part, [in] IMgaFCO* dst_part, [in] BSTR connection_role, [out, retval] IMgaConnection ** conn );
	HRESULT DisconnectFCOs( [in] IMgaFCO* src_part, [in] IMgaFCO* dst_part, [in] BSTR connection_name);

	HRESULT Refer( [in] BSTR reference, [in] BSTR referred);
	HRESULT ClearRef( [in] BSTR reference);
	HRESULT FollowRef( [in] BSTR reference);

	HRESULT ReferFCO( [in] IMgaReference* reference, [in] IMgaFCO* referred);
	HRESULT ClearRefFCO( [in] IMgaReference* reference);
	HRESULT FollowRefFCO( [in] IMgaReference* reference);
	HRESULT NullFCO( [out, retval] IMgaFCO** nullobj);


	HRESULT SetAttribute( [in] BSTR name, [in] BSTR attr_name, [in] VARIANT value);
	HRESULT GetAttribute( [in] BSTR name, [in] BSTR attr_name, [out, retval] VARIANT* value);

	HRESULT SetAttributeFCO( [in] IMgaFCO* fco, [in] BSTR attr_name, [in] VARIANT value);
	HRESULT GetAttributeFCO( [in] IMgaFCO* fco, [in] BSTR attr_name, [out, retval] VARIANT* value);

	HRESULT SubType( [in] BSTR base, [in] BSTR name_of_subtype, [out, retval] IMgaFCO** subtype);	
	HRESULT Instantiate( [in] BSTR base, [in] BSTR name_of_instance, [out, retval] IMgaFCO** instance);

	HRESULT SubTypeFCO( [in] IMgaFCO* base, [in] BSTR name_of_subtype, [out, retval] IMgaFCO** subtype);
	HRESULT InstantiateFCO( [in] IMgaFCO* base, [in] BSTR name_of_instance, [out, retval] IMgaFCO** instance);

	HRESULT BeginTransaction();
	HRESULT CommitTransaction();
	HRESULT AbortTransaction();
	HRESULT IsInTransaction( [out, retval] VARIANT_BOOL* intrans);
	HRESULT PutInTerritory( [in] IMgaFCO* fco, [out, retval] IMgaFCO** newfco);

	HRESULT Help();

	HRESULT SetSelected( [in] BSTR space_delimited_string );
	HRESULT GetSelected( [out, retval] BSTR * space_delimited_string );
	HRESULT SetSelectedFCOs([in] IMgaFCOs* fcos_to_select);
	HRESULT GetSelectedFCOs([out, retval] IMgaFCOs** selected_fcos);


	[helpstring("switches to the next aspect of this view (opened model)")]
	HRESULT NextAspect();
	HRESULT PrevAspect();

	[helpstring("makes the next (if any) view (opened model) the active view ")]
	HRESULT Next();
	HRESULT Prev();

	HRESULT Position( [in] BSTR child, [in] BSTR aspect, [in] long parX, [in] long parY);
	HRESULT PositionFCO( [in] IMgaFCO* fco, [in] BSTR aspect, [in] long parX, [in] long parY);
};

//  Primary dispatch interface for CGMEOLEModel

[ uuid(399A16A0-D209-4d00-9BDF-858D87EC4641),
	oleautomation,
	dual 
]
interface IGMEOLEModel : IDispatch // actually it corresponds to a view
{
	// properties:
	[propput, id(1)] HRESULT Active([in] VARIANT_BOOL isActive);
	[propget, id(1)] HRESULT Active([out, retval] VARIANT_BOOL* isActive);
	[propget, id(2)] HRESULT Aspects([out, retval] IGMEOLEColl** coll);
	[propget, id(3)] HRESULT MgaModel([out, retval] IMgaModel** model);
	[propget, id(4)] HRESULT Valid([out, retval] VARIANT_BOOL* isValid);
		
	// methods:
	[id(5)] HRESULT Print();
	[id(6)] HRESULT PrintDialog();
	[id(7)] HRESULT DumpWindowsMetaFile([in] BSTR filePath);
	[id(8)] HRESULT CheckConstraints();
	[id(9)] HRESULT RunComponent([in] BSTR appID);
	[id(10)] HRESULT RunComponentDialog();
	[id(11)] HRESULT Close();
	[id(12)] HRESULT GrayOutFCO([in] VARIANT_BOOL bGray, [in] VARIANT_BOOL bNeighbours, [in] IMgaFCOs* mgaFCO);
	[id(13)] HRESULT GrayOutHide();
	[id(14)] HRESULT ShowSetMembers([in] IMgaFCO* mgaFCO); // set is in this open model
	[id(15)] HRESULT HideSetMembers();
	[id(16)] HRESULT Zoom([in] DWORD percent); // for open models only
	[id(17)] HRESULT ZoomTo([in] IMgaFCOs* mgaFCOs); // for open models only
	[id(18)] HRESULT Scroll([in] bar_enum, [in] scroll_enum); // for opened models only

};


//  Primary dispatch interface for CGMEOLEAspect

[ uuid(EDEEB1F8-BC44-40d2-BE91-83E8CCD59845),
	oleautomation, 
	dual
]
interface IGMEOLEAspect : IDispatch
{
	// properties:
	[propget, id(1)] HRESULT MgaAspect([out, retval] IMgaMetaAspect** aspect);
	[propput, id(2)] HRESULT Active([in] VARIANT_BOOL isActive);
	[propget, id(2)] HRESULT Active([out, retval] VARIANT_BOOL* isActive);
	[propget, id(3)] HRESULT Valid([out, retval] VARIANT_BOOL* isValid);

	// methods:
};


//  Primary dispatch interface for CGMEOLEPanel

[ uuid(C047FAEB-7AE7-40fb-8C5C-90C73DAD4BC6), 
	oleautomation, 
	dual
]
interface IGMEOLEPanel :  IDispatch
{
	// properties:
	[propget, id(1)] HRESULT Name([out, retval] BSTR* name);
	[propput, id(2)] HRESULT Visible([in] VARIANT_BOOL isVisible);
	[propget, id(2)] HRESULT Visible([out, retval] VARIANT_BOOL* isVisible);
	[propget, id(3)] HRESULT Interface([out, retval] IDispatch** interf);
		
	// methods:
};


//  Primary dispatch interface for CGMEOLEColl

[ uuid(36C7B797-6BDE-46d0-8870-70189000EDF9),
	oleautomation,
	dual
]
interface IGMEOLEColl : IDispatch
{
	[propget, id(1)] HRESULT Count([out, retval] long *cnt);
	
	[id(2)] HRESULT Add(IDispatch* newValue);
	[id(3)] HRESULT Find(IDispatch* findValue, [out, retval] long *cnt);
	[id(4)] HRESULT Remove(VARIANT removeValue);
	[id(5)] HRESULT RemoveAll();

	[propget, id(DISPID_VALUE)] HRESULT Item(long nIndex, [out, retval] IDispatch** val);
	[propput, id(DISPID_VALUE)] HRESULT Item(long nIndex, IDispatch* newValue);
	[propget, id(DISPID_NEWENUM)] HRESULT _NewEnum([out, retval] IUnknown** e);
};

// --------------------------- Gme IDL



// --------------------------- VersionInfo

typedef enum MgaInterfaceVersion_enum
{
	MgaInterfaceVersion_None = 0,
	MgaInterfaceVersion_Legacy = 4,
	MgaInterfaceVersion_Current = INTERFACE_VERSION
} MgaInterfaceVersion_enum;

cpp_quote("#define MgaInterfaceVersion MgaInterfaceVersion_enum")

[
	oleautomation,
	uuid(9A228010-020B-11d2-BBB3-0040051F7117),
	helpstring("Mga VersionInfo Interface")
]
interface IMgaVersionInfo : IUnknown
{
	[propget, helpstring("property version")]
	HRESULT version([out, retval] MgaInterfaceVersion_enum *pVal);
};

//-------------------------------------------------------------------------------
typedef enum RoutingDirection
{
	Dir_None	= -1,
	Dir_Top		= 0,
	Dir_Right	= 1,
	Dir_Bottom	= 2,
	Dir_Left	= 3,
	Dir_Skew	= 4
} RoutingDirection;


// Type of edge customization
typedef enum PathCustomizationType
{
	Invalid						= 0,
	SimpleEdgeDisplacement		= 1,
	CustomPointCustomization	= 2,
	NURBSEdgeCustomization		= 3,
	NumOfPathCustomizationTypes	= 4
} PathCustomizationType;

[uuid(6EFD7B53-3D5D-4c17-89A7-4F3F401563A0)]
// Structure for storing edge customization data
struct CustomPathData
{
	[helpstring("Version number of structure")]
	long version;
	[helpstring("Which aspect does customization refers to")]
	long aspect;
	[helpstring("The index of the given edge in the edge array")]
	long edgeIndex;
	[helpstring("The number of the edges in the array")]
	long edgeCount;
	[helpstring("Type of the customization: simple displacement, NURBS curving, etc")]
	PathCustomizationType type;
	[helpstring("Tells if the displacement to an x or y coordinate")]
	boolean horizontalOrVerticalEdge;
	[helpstring("An x coordinate")]
	long x;
	[helpstring("An y coordinate")]
	long y;

	[helpstring("Additional long data no 1")]
	long l1;
	[helpstring("Additional long data no 2")]
	long l2;
	[helpstring("Additional long data no 3")]
	long l3;
	[helpstring("Additional long data no 4")]
	long l4;
	[helpstring("Additional double data no 1")]
	double d1;
	[helpstring("Additional double data no 2")]
	double d2;
	[helpstring("Additional double data no 3")]
	double d3;
	[helpstring("Additional double data no 4")]
	double d4;
	[helpstring("Additional double data no 5")]
	double d5;
	[helpstring("Additional double data no 6")]
	double d6;
	[helpstring("Additional double data no 7")]
	double d7;
	[helpstring("Additional double data no 8")]
	double d8;
};


interface IAutoRouterBox;

[
	object,
	uuid(87C3FC61-A245-4958-BACE-31313724D56A),
	dual,
	nonextensible,
	helpstring("IAutoRouterPort Interface"),
	pointer_default(unique)
]
interface IAutoRouterPort : IDispatch
{
	[id(1)] HRESULT GetOwner([out, retval] IAutoRouterBox** result);
	[id(2)] HRESULT HasOwner([out, retval] VARIANT_BOOL* result);
	[id(3)] HRESULT SetOwner([in] IAutoRouterBox* graph);

	[id(4)] HRESULT GetRect([out] long* p1, [out] long* p2, [out] long* p3, [out] long* p4);
	[id(5)] HRESULT IsRectEmpty([out, retval] VARIANT_BOOL* result);
	[id(6)] HRESULT GetCenter([out] long* px, [out] long* py);
	[id(7)] HRESULT SetRect([in] long p1, [in] long p2, [in] long p3, [in] long p4);
	[id(8)] HRESULT ShiftBy([in] long offsetx, [in] long offsety);
	[id(9)] HRESULT GetSelfPoints([out] long* p1x, [out] long* p1y, [out] long* p2x, [out] long* p2y, [out] long* p3x, [out] long* p3y, [out] long* p4x, [out] long* p4y);

	[id(10)] HRESULT GetAttributes([out,retval] long* result);
	[id(11)] HRESULT SetAttributes([in] long attr);
	[id(12)] HRESULT IsConnectToCenter([out,retval] VARIANT_BOOL* result);
	[id(13)] HRESULT HasLimitedDirs([out,retval] VARIANT_BOOL* result);
	[id(14)] HRESULT SetLimitedDirs([in] VARIANT_BOOL ltd);

	[id(15)] HRESULT IsPortAt([in] long px, [in] long py, [in] long nearness, [out, retval] VARIANT_BOOL* result);
	[id(16)] HRESULT IsPortClip([in] long p1, [in] long p2, [in] long p3, [in] long p4, [out, retval] VARIANT_BOOL* result);
	[id(17)] HRESULT IsPortIn([in] long p1, [in] long p2, [in] long p3, [in] long p4, [out, retval] VARIANT_BOOL* result);
	[id(18)] HRESULT OnWhichEdge([in] long px, [in] long py, [out, retval] RoutingDirection* result);

	[id(19)] HRESULT CanHaveStartEndPointOn([in] RoutingDirection dir, [in] long isstart, [out,retval] VARIANT_BOOL* result);
	[id(20)] HRESULT CanHaveStartEndPoint([in] long isstart, [out,retval] VARIANT_BOOL* result);
	[id(21)] HRESULT CanHaveStartEndPointHorizontal([in] long ishorizontal, [out,retval] VARIANT_BOOL* result);
	[id(22)] HRESULT GetStartEndDirTo([in] long px, [in] long py, [in] long isstart, [in] RoutingDirection notthis, [out,retval] RoutingDirection* result);

	[id(23)] HRESULT CanCreateStartEndPointAt([in] long px, [in] long py, [in] long isstart, [in] long nearness, [out,retval] VARIANT_BOOL* result);
	[id(24)] HRESULT CreateStartEndPointAt([in] long px, [in] long py, [in] long isstart, [out] long* resultX, [out] long* resultY);
	[id(25)] HRESULT CreateStartEndPointOn([in] RoutingDirection dir, [out] long* resultX, [out] long* resultY);
	[id(26)] HRESULT CreateStartEndPointTo([in] long px, [in] long py, [in] long isstart, [out] long* resultX, [out] long* resultY);
};

interface IAutoRouterGraph;

[
	object,
	uuid(6E17FD46-787A-4510-A43B-B416451F86FE),
	dual,
	nonextensible,
	helpstring("IAutoRouterBox Interface"),
	pointer_default(unique)
]
interface IAutoRouterBox : IDispatch
{
	[id(1)] HRESULT GetOwner([out, retval] IAutoRouterGraph** result);
	[id(2)] HRESULT HasOwner([out, retval] VARIANT_BOOL* result);
	[id(3)] HRESULT SetOwner([in] IAutoRouterGraph* graph);

	[id(4)] HRESULT CreatePort([out, retval] IAutoRouterPort** result);
	[id(5)] HRESULT HasNoPort([out, retval] VARIANT_BOOL* result);
	[id(6)] HRESULT GetPortCount([out, retval] long* result);
	[id(7)] HRESULT IsAtomic([out, retval] VARIANT_BOOL* result);
	[id(8)] HRESULT AddPort([in] IAutoRouterPort* port);
	[id(9)] HRESULT DeletePort([in] IAutoRouterPort* port);
	[id(10)] HRESULT GetPortList([out, retval] SAFEARRAY(IAutoRouterPort*)* pArr);

	[id(11)] HRESULT GetRect([out] long* p1, [out] long* p2, [out] long* p3, [out] long* p4);
	[id(12)] HRESULT IsRectEmpty([out, retval] VARIANT_BOOL* result);
	[id(13)] HRESULT SetRect([in] long p1, [in] long p2, [in] long p3, [in] long p4);
	[id(14)] HRESULT SetRectByPoint([in] long px, [in] long py);
	[id(15)] HRESULT ShiftBy([in] long offsetx, [in] long offsety);
	[id(16)] HRESULT GetSelfPoints([out] long* p1x, [out] long* p1y, [out] long* p2x, [out] long* p2y, [out] long* p3x, [out] long* p3y, [out] long* p4x, [out] long* p4y);

	[id(17)] HRESULT IsBoxAt([in] long px, [in] long py, [in] long nearness, [out, retval] VARIANT_BOOL* result);
	[id(18)] HRESULT IsBoxClip([in] long p1, [in] long p2, [in] long p3, [in] long p4, [out, retval] VARIANT_BOOL* result);
	[id(19)] HRESULT IsBoxIn([in] long p1, [in] long p2, [in] long p3, [in] long p4, [out, retval] VARIANT_BOOL* result);

	[id(20)] HRESULT Destroy();
};

[
	object,
	uuid(E472E1BB-9953-447E-BBE2-378C0DCB85E4),
	dual,
	nonextensible,
	helpstring("IAutoRouterPath Interface"),
	pointer_default(unique)
]
interface IAutoRouterPath : IDispatch
{
	[id(1)] HRESULT GetOwner([out, retval] IAutoRouterGraph** result);
	[id(2)] HRESULT HasOwner([out, retval] VARIANT_BOOL* result);
	[id(3)] HRESULT SetOwner([in] IAutoRouterGraph* graph);

	[id(4)] HRESULT SetStartPort([in] IAutoRouterPort* port);
	[id(5)] HRESULT SetEndPort([in] IAutoRouterPort* port);
	[id(6)] HRESULT ClearPorts();
	[id(7)] HRESULT GetStartPort([out, retval] IAutoRouterPort** result);
	[id(8)] HRESULT GetEndPort([out, retval] IAutoRouterPort** result);
	[id(9)] HRESULT AddTail([in] long px, [in] long py);
	[id(10)] HRESULT DeleteAll();
	[id(11)] HRESULT HasNoPoint([out, retval] VARIANT_BOOL* result);
	[id(12)] HRESULT GetPointCount([out, retval] long* result);
	[id(13)] HRESULT GetStartPoint([out] long* resultX, [out] long* resultY);
	[id(14)] HRESULT GetEndPoint([out] long* resultX, [out] long* resultY);
	[id(15)] HRESULT GetStartBox([out] long* p1, [out] long* p2, [out] long* p3, [out] long* p4);
	[id(16)] HRESULT GetEndBox([out] long* p1, [out] long* p2, [out] long* p3, [out] long* p4);
	[id(17)] HRESULT GetOutOfBoxStartPoint([out] long* resultX, [out] long* resultY, [in] RoutingDirection hintDir);
	[id(18)] HRESULT GetOutOfBoxEndPoint([out] long* resultX, [out] long* resultY, [in] RoutingDirection hintDir);
	[id(19)] HRESULT SimplifyTrivially();

	[id(20)] HRESULT ModifyPoints([in] SAFEARRAY(long) pArr);
	[id(21)] HRESULT SetPoints([in] SAFEARRAY(long) pArr);
	[id(22)] HRESULT GetPointList([out, retval] SAFEARRAY(long)* pArr);

	[id(23)] HRESULT GetSurroundRect([out] long* p1, [out] long* p2, [out] long* p3, [out] long* p4);
	[id(24)] HRESULT IsEmpty([out, retval] VARIANT_BOOL* result);
	[id(25)] HRESULT IsPathAt([in] long px, [in] long py, [in] long nearness, [out, retval] VARIANT_BOOL* result);
	[id(26)] HRESULT IsPathClip([in] long p1, [in] long p2, [in] long p3, [in] long p4, [out, retval] VARIANT_BOOL* result);
	[id(27)] HRESULT SetAttributes([in] long attr);
	[id(28)] HRESULT GetAttributes([out, retval] long* result);
	[id(29)] HRESULT IsFixed([out, retval] VARIANT_BOOL* result);
	[id(30)] HRESULT IsMoveable([out, retval] VARIANT_BOOL* result);
	[id(31)] HRESULT IsHighLighted([out, retval] VARIANT_BOOL* result);
	[id(32)] HRESULT GetState([out, retval] long* result);
	[id(33)] HRESULT IsConnected([out, retval] VARIANT_BOOL* result);
	[id(34)] HRESULT SetState([in] long state);
	[id(35)] HRESULT GetEndDir([out, retval] RoutingDirection* result);
	[id(36)] HRESULT GetStartDir([out, retval] RoutingDirection* result);
	[id(37)] HRESULT SetEndDir([in] long arpath_end);
	[id(38)] HRESULT SetStartDir([in] long arpath_start);

	[id(39)] HRESULT SetCustomPathData([in] SAFEARRAY(struct CustomPathData) pArr);
	[id(40)] HRESULT ApplyCustomizationsBeforeAutoConnectPoints([in, out] SAFEARRAY(long)* pArr);
	[id(41)] HRESULT ApplyCustomizationsAfterAutoConnectPointsAndStuff();
	[id(42)] HRESULT RemovePathCustomizations();
	[id(43)] HRESULT MarkPathCustomizationsForDeletion([in] long aspect);
	[id(44)] HRESULT RemoveInvalidPathCustomizations([in] long aspect);
	[id(45)] HRESULT AreTherePathCustomizations([out, retval] VARIANT_BOOL* result);
	[id(46)] HRESULT AreThereDeletedPathCustomizations([out, retval] VARIANT_BOOL* result);
	[id(47)] HRESULT GetDeletedCustomPathData([out, retval] SAFEARRAY(struct CustomPathData)* pArr);
	[id(48)] HRESULT GetFixedEdgeIndexes([out, retval] SAFEARRAY(long)* pArr);

	[id(49)] HRESULT IsAutoRouted([out, retval] VARIANT_BOOL* result);
	[id(50)] HRESULT SetAutoRouting([in] VARIANT_BOOL autoRoutingState);

	[id(51)] HRESULT Destroy();
};

[
	object,
	uuid(C86D598D-C58B-4D17-93EC-8C3BF1157073),
	dual,
	nonextensible,
	helpstring("IAutoRouterGraph Interface"),
	pointer_default(unique)
]
interface IAutoRouterGraph : IDispatch
{
	[id(1)] HRESULT CreateBox([out, retval] IAutoRouterBox** result);
	[id(2)] HRESULT AddBox([in] IAutoRouterBox* box);
	[id(3)] HRESULT DeleteBox([in] IAutoRouterBox* box);
	[id(4)] HRESULT ShiftBoxBy([in] IAutoRouterBox* box, [in] long sizeX, [in] long sizeY);

	[id(5)] HRESULT AutoRoute([in] long aspect, [out, retval] long* result);
	[id(6)] HRESULT DeletePath([in] IAutoRouterPath* path);
	[id(7)] HRESULT DeleteAll();
	[id(8)] HRESULT GetPathAt([in] long pointX, [in] long pointY, [in] long nearness, [out, retval] IAutoRouterPath** result);
	[id(9)] HRESULT AddPath([in] VARIANT_BOOL isAutoRouted, [in] IAutoRouterPort* startport, [in] IAutoRouterPort* endport, [out, retval] IAutoRouterPath** result);
	[id(10)] HRESULT IsEdgeFixed([in] IAutoRouterPath* path, [in] long startX, [in] long startY, [in] long endX, [in] long endY, [out, retval] VARIANT_BOOL* result);

	[id(11)] HRESULT GetSelfPoints([out] long* p1x, [out] long* p1y, [out] long* p2x, [out] long* p2y, [out] long* p3x, [out] long* p3y, [out] long* p4x, [out] long* p4y);

	[id(12)] HRESULT Destroy();
};
